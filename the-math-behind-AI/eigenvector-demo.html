<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eigenvalue & Eigenvector 特征值与特征向量</title>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #0a0a0f;
      --bg-card: #111118;
      --accent-cyan: #00d4ff;
      --accent-magenta: #ff00aa;
      --accent-yellow: #ffd000;
      --text-primary: #e8e8f0;
      --text-muted: #8888a0;
      --border: #2a2a3a;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Crimson Pro', Georgia, serif;
      background: var(--bg-dark);
      color: var(--text-primary);
      min-height: 100vh;
      padding: 0.5rem;
      font-size: 14px;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 280px 1fr;
      grid-template-rows: auto 1fr;
      gap: 0.5rem;
      height: calc(100vh - 1rem);
    }

    @media (max-width: 800px) {
      .main-grid { grid-template-columns: 1fr; grid-template-rows: auto auto auto; }
    }

    header {
      grid-column: 1 / -1;
      display: flex;
      align-items: baseline;
      gap: 1rem;
      padding: 0.25rem 0.5rem;
      border-bottom: 1px solid var(--border);
    }

    h1 {
      font-size: 1.3rem;
      font-weight: 600;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      color: var(--text-muted);
      font-size: 0.85rem;
      font-style: italic;
    }

    .left-panel {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      min-height: 0;
      overflow-y: auto;
    }

    .left-panel::-webkit-scrollbar { width: 4px; }
    .left-panel::-webkit-scrollbar-track { background: var(--bg-dark); }
    .left-panel::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

    .card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem;
      position: relative;
    }

    .card-title {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
      font-family: 'JetBrains Mono', monospace;
    }

    .matrix-input-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.3rem;
      padding: 0.5rem;
    }

    .matrix-label {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.2rem;
      color: var(--text-primary);
      margin-right: 0.3rem;
    }

    .matrix-bracket {
      font-family: 'JetBrains Mono', monospace;
      font-size: 3rem;
      color: var(--accent-cyan);
      font-weight: 100;
      line-height: 1;
    }

    .matrix-bracket.left {
      margin-right: 0.2rem;
    }

    .matrix-bracket.right {
      margin-left: 0.2rem;
    }

    .matrix-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap: 0.4rem;
    }

    .matrix-cell {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1rem;
      color: var(--accent-yellow);
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid var(--border);
      border-radius: 4px;
      width: 60px;
      height: 36px;
      padding: 0.3rem;
      text-align: center;
    }

    .matrix-cell:focus {
      outline: none;
      border-color: var(--accent-cyan);
      background: rgba(0, 212, 255, 0.1);
    }

    .matrix-cell.selected {
      border-color: var(--accent-magenta);
      box-shadow: 0 0 0 1px var(--accent-magenta);
    }

    .matrix-cell::-webkit-inner-spin-button,
    .matrix-cell::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    .matrix-slider-container {
      display: flex;
      justify-content: center;
      padding: 0.5rem 1rem 0.3rem;
    }

    .matrix-slider-container input[type="range"] {
      width: 160px;
      height: 6px;
      -webkit-appearance: none;
      background: var(--accent-magenta);
      border-radius: 3px;
      outline: none;
    }

    .matrix-slider-container input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: var(--accent-yellow);
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid var(--bg-dark);
    }

    .matrix-slider-container input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: var(--accent-yellow);
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid var(--bg-dark);
    }

    .presets-container {
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem;
      padding: 0.4rem 0.5rem;
      align-items: center;
      border-top: 1px solid var(--border);
    }

    .presets-label {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.6rem;
      color: var(--text-muted);
      margin-right: 0.2rem;
    }

    .preset-btn {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.55rem;
      padding: 0.25rem 0.4rem;
      background: rgba(0, 212, 255, 0.1);
      border: 1px solid var(--accent-cyan);
      color: var(--accent-cyan);
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .preset-btn:hover {
      background: var(--accent-cyan);
      color: var(--bg-dark);
    }

    .results-compact {
      display: grid;
      grid-template-columns: 0.6fr 1fr;
      gap: 0.35rem;
    }

    .result-item {
      background: rgba(0, 0, 0, 0.3);
      padding: 0.4rem;
      border-radius: 4px;
      border-left: 2px solid var(--accent-cyan);
    }

    .result-item:nth-child(even) { border-left-color: var(--accent-magenta); }

    .result-label {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.6rem;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    .result-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      color: var(--accent-yellow);
    }

    .viz-panel {
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .visualization {
      flex: 1;
      position: relative;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      overflow: hidden;
      min-height: 200px;
    }

    canvas { width: 100%; height: 100%; }

    .legend {
      position: absolute;
      top: 0.5rem;
      left: 0.5rem;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.65rem;
      background: rgba(0,0,0,0.6);
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin-bottom: 0.15rem;
    }

    .legend-item:last-child { margin-bottom: 0; }

    .legend-color {
      width: 14px;
      height: 2px;
      border-radius: 1px;
    }

    .controls {
      display: flex;
      gap: 0.75rem;
      align-items: center;
      padding: 0.4rem;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 0 0 6px 6px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
    }

    .controls label { color: var(--text-muted); }

    .controls input[type="range"] {
      flex: 1;
      height: 4px;
      -webkit-appearance: none;
      background: var(--border);
      border-radius: 2px;
      max-width: 200px;
    }

    .controls input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: var(--accent-cyan);
      border-radius: 50%;
      cursor: pointer;
    }

    .slider-label { color: var(--accent-yellow); }

    .btn-pause {
      background: var(--accent-cyan);
      border: none;
      color: var(--bg-dark);
      width: 28px;
      height: 28px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .btn-pause:hover { background: var(--accent-magenta); }

    .insight {
      padding: 0.4rem 0.6rem;
      background: rgba(255, 208, 0, 0.08);
      border-left: 2px solid var(--accent-yellow);
      font-size: 0.8rem;
      line-height: 1.4;
      margin-top: 0.5rem;
      border-radius: 0 4px 4px 0;
    }

    .step {
      background: rgba(255, 255, 255, 0.02);
      border-left: 2px solid var(--accent-cyan);
      padding: 0.4rem 0.5rem;
      margin-bottom: 0.35rem;
      border-radius: 0 4px 4px 0;
      font-size: 0.85rem;
    }

    .step:nth-child(even) { border-left-color: var(--accent-magenta); }

    .step-number {
      display: inline-block;
      width: 18px;
      height: 18px;
      background: var(--accent-cyan);
      color: var(--bg-dark);
      border-radius: 50%;
      text-align: center;
      line-height: 18px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      font-weight: 500;
      margin-right: 0.4rem;
    }

    .step:nth-child(even) .step-number { background: var(--accent-magenta); }

    .step-title { font-weight: 600; font-size: 0.8rem; }

    .step-content { margin-top: 0.3rem; line-height: 1.4; }

    .math {
      font-family: 'JetBrains Mono', monospace;
      background: rgba(0, 212, 255, 0.1);
      padding: 0.1rem 0.3rem;
      border-radius: 2px;
      font-size: 0.75rem;
    }

    .math-block {
      font-family: 'JetBrains Mono', monospace;
      background: rgba(0, 0, 0, 0.3);
      padding: 0.4rem;
      border-radius: 4px;
      margin: 0.3rem 0;
      font-size: 0.7rem;
      line-height: 1.5;
      white-space: pre;
    }

    .result-box {
      background: rgba(0, 212, 255, 0.08);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 0.4rem;
      margin-top: 0.3rem;
    }

    .result-box .result-value { font-size: 0.85rem; }

    .note {
      font-style: italic;
      color: var(--text-muted);
      font-size: 0.75rem;
      padding-left: 0.5rem;
      border-left: 1px solid var(--border);
      margin-top: 0.3rem;
    }
  </style>
</head>
<body>
  <div class="main-grid">
    <header>
      <h1>Eigenvalue & Eigenvector 特征值与特征向量</h1>
      <span class="subtitle">Interactive 2×2 matrix computation 交互式2×2矩阵计算</span>
    </header>

    <div class="left-panel">
      <div class="card">
        <div class="card-title">Matrix A 矩阵</div>
        <div class="matrix-input-container">
          <span class="matrix-label">A =</span>
          <div class="matrix-bracket left">[</div>
          <div class="matrix-grid">
            <input type="number" class="matrix-cell" id="a11-val" value="2.00" step="0.01" oninput="updateFromInput('a11')" onfocus="selectCell('a11')">
            <input type="number" class="matrix-cell" id="a12-val" value="1.00" step="0.01" oninput="updateFromInput('a12')" onfocus="selectCell('a12')">
            <input type="number" class="matrix-cell" id="a21-val" value="0.00" step="0.01" oninput="updateFromInput('a21')" onfocus="selectCell('a21')">
            <input type="number" class="matrix-cell" id="a22-val" value="3.00" step="0.01" oninput="updateFromInput('a22')" onfocus="selectCell('a22')">
          </div>
          <div class="matrix-bracket right">]</div>
          <!-- Hidden range inputs for compatibility -->
          <input type="range" id="a11" min="-10" max="10" value="2" step="0.01" style="display:none">
          <input type="range" id="a12" min="-10" max="10" value="1" step="0.01" style="display:none">
          <input type="range" id="a21" min="-10" max="10" value="0" step="0.01" style="display:none">
          <input type="range" id="a22" min="-10" max="10" value="3" step="0.01" style="display:none">
        </div>
        <div class="matrix-slider-container">
          <input type="range" id="matrix-slider" min="-10" max="10" value="2" step="0.01" oninput="updateFromMatrixSlider()">
        </div>
        <div class="presets-container">
          <span class="presets-label">Presets 预设:</span>
          <button class="preset-btn" onclick="loadPreset('triangular')">Triangular 三角</button>
          <button class="preset-btn" onclick="loadPreset('singular')">Singular 奇异</button>
          <button class="preset-btn" onclick="loadPreset('scalar')">Scalar 标量</button>
          <button class="preset-btn" onclick="loadPreset('symmetric')">Symmetric 对称</button>
          <button class="preset-btn" onclick="loadPreset('rotation')">Rotation 旋转</button>
        </div>
      </div>

      <div class="card" id="results-card">
        <div class="card-title">Results 结果</div>
        <div class="results-compact" id="results-compact">
          <div class="result-item">
            <div class="result-label">λ₁ 特征值</div>
            <div class="result-value" id="lambda1">—</div>
          </div>
          <div class="result-item">
            <div class="result-label">v₁ 特征向量</div>
            <div class="result-value" id="ev1">—</div>
          </div>
          <div class="result-item">
            <div class="result-label">λ₂ 特征值</div>
            <div class="result-value" id="lambda2">—</div>
          </div>
          <div class="result-item">
            <div class="result-label">v₂ 特征向量</div>
            <div class="result-value" id="ev2">—</div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-title">Steps 步骤</div>
        <div id="steps-container">
          <p class="note">Computing... 计算中...</p>
        </div>
      </div>
    </div>

    <div class="viz-panel card">
      <div class="card-title">Geometric Visualization 几何可视化</div>
      <div class="visualization">
        <canvas id="canvas"></canvas>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color" style="background: #ffffff;"></div>
            <span>v (original 原向量)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #ffd000;"></div>
            <span>Av (transformed 变换后)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #00d4ff;"></div>
            <span>Eigenvector 特征向量 v₁</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #ff00aa;"></div>
            <span>Eigenvector 特征向量 v₂</span>
          </div>
        </div>
      </div>
      <div class="controls">
        <button class="btn-pause" id="pause-btn" onclick="togglePause()">⏸</button>
        <span class="slider-label">Rotate Vector Mode 旋转向量模式</span>
      </div>
      <div class="insight" id="insight-text">
        Watch vector <strong>v</strong> rotate 360°. When <strong>v</strong> aligns with an eigenvector direction, <strong>v</strong> and <strong>Av</strong> become parallel (same color). The animation pauses briefly to highlight this!<br>
        观察向量 <strong>v</strong> 旋转360°。当 <strong>v</strong> 与特征向量方向对齐时，<strong>v</strong> 和 <strong>Av</strong> 变为平行（同色）。动画会短暂暂停以突出显示！
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let animationId;
    let currentT = 0;
    let isPaused = false;
    let matrixA = { a: 2, b: 1, c: 0, d: 3 };
    let eigenData = { ev1: null, ev2: null, l1: null, l2: null };
    let trails = []; // Store trail points for each vector
    let lastT = 0; // Track when t resets
    let rotationAngle = 0; // Current angle for rotation mode
    let eigenPauseFrames = 0; // Counter for pausing at eigenvector
    let lastEigenHit = -1; // Track which eigenvector was last hit to avoid repeat pauses
    let selectedCell = 'a11'; // Currently selected matrix cell

    // Generate points on a unit circle for the shape
    const numPoints = 48;
    const shapePoints = [];
    for (let i = 0; i < numPoints; i++) {
      const angle = (i / numPoints) * Math.PI * 2;
      shapePoints.push([Math.cos(angle), Math.sin(angle)]);
    }
    
    // Key direction vectors to highlight (including eigenvectors)
    const numVectors = 8;
    const inputVectors = [];
    for (let i = 0; i < numVectors; i++) {
      const angle = (i / numVectors) * Math.PI * 2;
      inputVectors.push([Math.cos(angle), Math.sin(angle)]);
    }
    
    // Initialize trails for vectors
    function initTrails() {
      trails = [];
      for (let i = 0; i < numVectors + 2; i++) {
        trails.push([]);
      }
    }
    initTrails();

    function setupCanvas() {
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width * 2;
      canvas.height = rect.height * 2;
      ctx.scale(2, 2);
    }
    
    function resizeCanvas() {
      setupCanvas();
      drawRotateMode();
    }
    window.addEventListener('resize', resizeCanvas);

    function togglePause() {
      isPaused = !isPaused;
      document.getElementById('pause-btn').textContent = isPaused ? '▶' : '⏸';
      if (!isPaused) animate();
    }

    function loadPreset(name) {
      const presets = {
        'triangular': { a11: 2, a12: 1, a21: 0, a22: 3 },      // Upper triangular, eigenvalues on diagonal
        'singular': { a11: 0.5, a12: 0.15, a21: 1, a22: 0.3 }, // det=0, λ₂=0
        'scalar': { a11: 3, a12: 0, a21: 0, a22: 3 },          // All vectors are eigenvectors
        'symmetric': { a11: 2, a12: 1, a21: 1, a22: 2 },       // Symmetric, orthogonal eigenvectors
        'rotation': { a11: 0, a12: -1, a21: 1, a22: 0 }        // 90° rotation, complex eigenvalues
      };
      
      const p = presets[name];
      if (!p) return;
      
      document.getElementById('a11-val').value = p.a11.toFixed(2);
      document.getElementById('a12-val').value = p.a12.toFixed(2);
      document.getElementById('a21-val').value = p.a21.toFixed(2);
      document.getElementById('a22-val').value = p.a22.toFixed(2);
      
      document.getElementById('a11').value = p.a11;
      document.getElementById('a12').value = p.a12;
      document.getElementById('a21').value = p.a21;
      document.getElementById('a22').value = p.a22;
      
      selectCell('a11');
      compute();
    }

    function updateFromInput(id) {
      let val = parseFloat(document.getElementById(id + '-val').value);
      if (isNaN(val)) val = 0;
      document.getElementById(id).value = val;
      document.getElementById('matrix-slider').value = val;
      compute();
    }

    function selectCell(id) {
      selectedCell = id;
      const val = parseFloat(document.getElementById(id + '-val').value);
      document.getElementById('matrix-slider').value = val;
      
      // Update visual selection
      document.querySelectorAll('.matrix-cell').forEach(cell => cell.classList.remove('selected'));
      document.getElementById(id + '-val').classList.add('selected');
    }

    function updateFromMatrixSlider() {
      const val = parseFloat(document.getElementById('matrix-slider').value);
      document.getElementById(selectedCell + '-val').value = val.toFixed(2);
      document.getElementById(selectedCell).value = val;
      compute();
    }

    function setupKeyboardNav() {
      // Matrix layout: a11 a12
      //                a21 a22
      const matrixNav = {
        'a11': { right: 'a12', down: 'a21', left: 'a12', up: 'a21' },
        'a12': { right: 'a11', down: 'a22', left: 'a11', up: 'a22' },
        'a21': { right: 'a22', down: 'a11', left: 'a22', up: 'a11' },
        'a22': { right: 'a21', down: 'a12', left: 'a21', up: 'a12' }
      };
      
      Object.keys(matrixNav).forEach(id => {
        document.getElementById(id + '-val').addEventListener('keydown', (e) => {
          const nav = matrixNav[id];
          let targetId = null;
          
          if (e.key === 'ArrowRight' || e.key === 'Right') targetId = nav.right;
          else if (e.key === 'ArrowLeft' || e.key === 'Left') targetId = nav.left;
          else if (e.key === 'ArrowDown' || e.key === 'Down') targetId = nav.down;
          else if (e.key === 'ArrowUp' || e.key === 'Up') targetId = nav.up;
          
          if (targetId) {
            e.preventDefault();
            document.getElementById(targetId + '-val').focus();
          }
        });
      });
    }

    function animate() {
      if (isPaused) return;
      
      // Check if we're pausing at an eigenvector
      if (eigenPauseFrames > 0) {
        eigenPauseFrames--;
        drawRotateMode();
        animationId = requestAnimationFrame(animate);
        return;
      }
      
      rotationAngle += 0.0075;
      if (rotationAngle > Math.PI * 2) {
        rotationAngle -= Math.PI * 2;
        lastEigenHit = -1; // Reset for next rotation
      }
      
      // Check if we're at an eigenvector (pause without snapping)
      if (eigenData.ev1 && eigenData.ev2) {
        const v = [Math.cos(rotationAngle), Math.sin(rotationAngle)];
        
        // Use dot product to check alignment (accounts for both directions)
        const dot1 = Math.abs(v[0] * eigenData.ev1[0] + v[1] * eigenData.ev1[1]);
        const dot2 = Math.abs(v[0] * eigenData.ev2[0] + v[1] * eigenData.ev2[1]);
        
        // Threshold: about 0.25 degrees from exact alignment
        const threshold = 0.99999;
        
        if (dot1 > threshold && lastEigenHit !== 1) {
          eigenPauseFrames = 120; // Pause for ~2 seconds (120 frames)
          lastEigenHit = 1;
        } else if (dot2 > threshold && lastEigenHit !== 2) {
          eigenPauseFrames = 120;
          lastEigenHit = 2;
        }
        
        // Reset when far from eigenvectors
        if (dot1 < 0.9 && lastEigenHit === 1) lastEigenHit = -1;
        if (dot2 < 0.9 && lastEigenHit === 2) lastEigenHit = -1;
      }
      
      drawRotateMode();
      
      animationId = requestAnimationFrame(animate);
    }

    function transformVector(v, t) {
      const { a, b, c, d } = matrixA;
      const transformed = [
        a * v[0] + b * v[1],
        c * v[0] + d * v[1]
      ];
      return [
        v[0] + t * (transformed[0] - v[0]),
        v[1] + t * (transformed[1] - v[1])
      ];
    }

    function drawArrow(fromX, fromY, toX, toY, color, lineWidth) {
      const headLen = 12;
      const angle = Math.atan2(toY - fromY, toX - fromX);
      const arrowWidth = lineWidth * 2;
      
      // Draw line
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX - headLen * Math.cos(angle), toY - headLen * Math.sin(angle));
      ctx.stroke();
      
      // Draw arrow head
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(toX, toY);
      ctx.lineTo(
        toX - headLen * Math.cos(angle) + arrowWidth * Math.cos(angle + Math.PI/2),
        toY - headLen * Math.sin(angle) + arrowWidth * Math.sin(angle + Math.PI/2)
      );
      ctx.lineTo(
        toX - headLen * Math.cos(angle) + arrowWidth * Math.cos(angle - Math.PI/2),
        toY - headLen * Math.sin(angle) + arrowWidth * Math.sin(angle - Math.PI/2)
      );
      ctx.closePath();
      ctx.fill();
    }

    function drawRotateMode() {
      const width = canvas.width / 2;
      const height = canvas.height / 2;
      const centerX = width / 2;
      const centerY = height / 2;
      const scale = Math.min(width, height) / 24;
      const vecLength = 3;

      ctx.clearRect(0, 0, width, height);

      // Draw grid
      ctx.strokeStyle = '#1a1a2a';
      ctx.lineWidth = 1;
      for (let i = -15; i <= 15; i++) {
        ctx.beginPath();
        ctx.moveTo(centerX + i * scale, 0);
        ctx.lineTo(centerX + i * scale, height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, centerY + i * scale);
        ctx.lineTo(width, centerY + i * scale);
        ctx.stroke();
      }

      // Draw axes
      ctx.strokeStyle = '#3a3a4a';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, centerY);
      ctx.lineTo(width, centerY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(centerX, 0);
      ctx.lineTo(centerX, height);
      ctx.stroke();

      // Draw eigenvector direction lines (dashed)
      if (eigenData.ev1 && eigenData.ev2) {
        [{ ev: eigenData.ev1, color: '#00d4ff' }, { ev: eigenData.ev2, color: '#ff00aa' }].forEach(({ ev, color }) => {
          ctx.strokeStyle = color;
          ctx.globalAlpha = 0.3;
          ctx.lineWidth = 2;
          ctx.setLineDash([6, 6]);
          ctx.beginPath();
          ctx.moveTo(centerX - ev[0] * vecLength * scale * 2, centerY + ev[1] * vecLength * scale * 2);
          ctx.lineTo(centerX + ev[0] * vecLength * scale * 2, centerY - ev[1] * vecLength * scale * 2);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.globalAlpha = 1;
        });
      }

      // Current rotating vector
      const v = [Math.cos(rotationAngle), Math.sin(rotationAngle)];
      
      // Transform the vector: Av
      const { a, b, c, d } = matrixA;
      const Av = [
        a * v[0] + b * v[1],
        c * v[0] + d * v[1]
      ];

      // Calculate positions
      const origX = centerX + v[0] * vecLength * scale;
      const origY = centerY - v[1] * vecLength * scale;
      const transX = centerX + Av[0] * vecLength * scale;
      const transY = centerY - Av[1] * vecLength * scale;

      // Check if this direction is close to an eigenvector
      let isEigenvector = false;
      let eigenvectorColor = '#ffd000';
      if (eigenData.ev1 && eigenData.ev2) {
        const dot1 = Math.abs(v[0] * eigenData.ev1[0] + v[1] * eigenData.ev1[1]);
        const dot2 = Math.abs(v[0] * eigenData.ev2[0] + v[1] * eigenData.ev2[1]);
        
        // Match the threshold used in animate() - about 0.25 degrees
        if (dot1 > 0.99999) {
          isEigenvector = true;
          eigenvectorColor = '#00d4ff';
        } else if (dot2 > 0.99999) {
          isEigenvector = true;
          eigenvectorColor = '#ff00aa';
        }
      }

      // Draw original vector v (white/cyan)
      drawArrow(centerX, centerY, origX, origY, isEigenvector ? eigenvectorColor : '#ffffff', 3);
      
      // Draw transformed vector Av (yellow/matching color)
      drawArrow(centerX, centerY, transX, transY, isEigenvector ? eigenvectorColor : '#ffd000', 3);

      // Draw dashed line connecting tips to show the difference
      if (!isEigenvector) {
        ctx.strokeStyle = 'rgba(255, 208, 0, 0.5)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(origX, origY);
        ctx.lineTo(transX, transY);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Draw dots at tips
      ctx.fillStyle = isEigenvector ? eigenvectorColor : '#ffffff';
      ctx.beginPath();
      ctx.arc(origX, origY, 5, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = isEigenvector ? eigenvectorColor : '#ffd000';
      ctx.beginPath();
      ctx.arc(transX, transY, 5, 0, Math.PI * 2);
      ctx.fill();

      // Draw origin
      ctx.fillStyle = '#ffd000';
      ctx.beginPath();
      ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
      ctx.fill();

      // Labels
      ctx.font = 'bold 12px JetBrains Mono';
      ctx.fillStyle = '#ffffff';
      ctx.fillText('v', origX + 10, origY - 10);
      ctx.fillStyle = '#ffd000';
      ctx.fillText('Av', transX + 10, transY - 10);

      // Angle display - positioned below HTML legend
      const angleDeg = (rotationAngle * 180 / Math.PI).toFixed(0);
      ctx.fillStyle = '#888';
      ctx.font = '11px JetBrains Mono';
      ctx.fillText(`Angle 角度: ${angleDeg}°`, 10, 110);
      
      // Status message
      if (isEigenvector) {
        ctx.fillStyle = eigenvectorColor;
        ctx.font = 'bold 12px JetBrains Mono';
        ctx.fillText(`✓ EIGENVECTOR! v and Av are parallel`, 10, 130);
        ctx.fillText(`✓ 特征向量！v 和 Av 平行`, 10, 148);
        const dot1 = Math.abs(v[0] * eigenData.ev1[0] + v[1] * eigenData.ev1[1]);
        const lambda = dot1 > 0.999 ? eigenData.l1 : eigenData.l2;
        ctx.fillText(`Av = ${lambda.toFixed(2)} × v`, 10, 166);
        
        // Show pause indicator
        if (eigenPauseFrames > 0) {
          ctx.fillStyle = eigenvectorColor;
          ctx.globalAlpha = 0.3 + 0.7 * (eigenPauseFrames / 120);
          ctx.font = 'bold 14px JetBrains Mono';
          ctx.fillText(`⏸ Paused 暂停`, 10, 186);
          ctx.globalAlpha = 1;
        }
      } else {
        ctx.fillStyle = '#888';
        ctx.font = '11px JetBrains Mono';
        ctx.fillText(`v and Av point in different directions`, 10, 130);
        ctx.fillText(`v 和 Av 指向不同方向`, 10, 145);
      }
    }

    function draw() {
      const width = canvas.width / 2;
      const height = canvas.height / 2;
      const centerX = width / 2;
      const centerY = height / 2;
      const scale = Math.min(width, height) / 15;

      ctx.clearRect(0, 0, width, height);

      // Draw grid
      ctx.strokeStyle = '#1a1a2a';
      ctx.lineWidth = 1;
      for (let i = -15; i <= 15; i++) {
        ctx.beginPath();
        ctx.moveTo(centerX + i * scale, 0);
        ctx.lineTo(centerX + i * scale, height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, centerY + i * scale);
        ctx.lineTo(width, centerY + i * scale);
        ctx.stroke();
      }

      // Draw axes
      ctx.strokeStyle = '#3a3a4a';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, centerY);
      ctx.lineTo(width, centerY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(centerX, 0);
      ctx.lineTo(centerX, height);
      ctx.stroke();

      // Reset trails when animation loops
      if (currentT < lastT - 0.5) {
        initTrails();
      }
      lastT = currentT;

      // Draw all NON-eigenvector input vectors (gray) - unless all are eigenvectors
      const vecLength = 2.5;
      const isScalarMatrix = eigenData.ev1 && eigenData.ev2 && 
        Math.abs(eigenData.l1 - eigenData.l2) < 0.0001 &&
        Math.abs(matrixA.b) < 0.0001 && Math.abs(matrixA.c) < 0.0001;
      
      // Draw ORIGINAL unit circle (dashed)
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      for (let i = 0; i <= shapePoints.length; i++) {
        const p = shapePoints[i % shapePoints.length];
        const x = centerX + p[0] * vecLength * scale;
        const y = centerY - p[1] * vecLength * scale;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Draw TRANSFORMED shape (solid)
      ctx.strokeStyle = isScalarMatrix ? '#00d4ff' : '#ffd000';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      for (let i = 0; i <= shapePoints.length; i++) {
        const p = shapePoints[i % shapePoints.length];
        const transformed = transformVector(p, currentT);
        const x = centerX + transformed[0] * vecLength * scale;
        const y = centerY - transformed[1] * vecLength * scale;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      
      // Fill transformed shape with transparency
      ctx.fillStyle = isScalarMatrix ? 'rgba(0, 212, 255, 0.1)' : 'rgba(255, 208, 0, 0.1)';
      ctx.beginPath();
      for (let i = 0; i <= shapePoints.length; i++) {
        const p = shapePoints[i % shapePoints.length];
        const transformed = transformVector(p, currentT);
        const x = centerX + transformed[0] * vecLength * scale;
        const y = centerY - transformed[1] * vecLength * scale;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.fill();
      
      // Draw direction lines from center through the shape
      inputVectors.forEach((v, idx) => {
        const transformed = transformVector(v, currentT);
        
        // Store trail point
        const trailX = centerX + transformed[0] * vecLength * scale;
        const trailY = centerY - transformed[1] * vecLength * scale;
        if (trails[idx] && (trails[idx].length === 0 || 
            Math.abs(trails[idx][trails[idx].length-1].x - trailX) > 0.5 ||
            Math.abs(trails[idx][trails[idx].length-1].y - trailY) > 0.5)) {
          trails[idx].push({ x: trailX, y: trailY });
        }
        
        // Draw trail
        if (trails[idx] && trails[idx].length > 1) {
          ctx.strokeStyle = isScalarMatrix ? 'rgba(0, 212, 255, 0.4)' : 'rgba(255, 208, 0, 0.4)';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(trails[idx][0].x, trails[idx][0].y);
          for (let i = 1; i < trails[idx].length; i++) {
            ctx.lineTo(trails[idx][i].x, trails[idx][i].y);
          }
          ctx.stroke();
        }
        
        // Draw original direction (dashed gray line)
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(centerX + v[0] * vecLength * scale, centerY - v[1] * vecLength * scale);
        ctx.stroke();
        ctx.setLineDash([]);
      });

      // Draw the ACTUAL eigenvectors (computed, not from fan) - skip if scalar matrix
      if (eigenData.ev1 && eigenData.ev2 && !isScalarMatrix) {
        const eigenvectors = [
          { ev: eigenData.ev1, lambda: eigenData.l1, color: '#00d4ff', label: 'v₁' },
          { ev: eigenData.ev2, lambda: eigenData.l2, color: '#ff00aa', label: 'v₂' }
        ];

        eigenvectors.forEach(({ ev, lambda, color, label }, eigIdx) => {
          // The eigenvector transforms to lambda * ev
          const scaleFactor = 1 + currentT * (lambda - 1);
          const transformedEv = [ev[0] * scaleFactor, ev[1] * scaleFactor];
          
          // Store trail point for eigenvector
          const trailIdx = numVectors + eigIdx;
          const trailX = centerX + transformedEv[0] * vecLength * scale;
          const trailY = centerY - transformedEv[1] * vecLength * scale;
          if (trails[trailIdx] && (trails[trailIdx].length === 0 || 
              Math.abs(trails[trailIdx][trails[trailIdx].length-1].x - trailX) > 0.5 ||
              Math.abs(trails[trailIdx][trails[trailIdx].length-1].y - trailY) > 0.5)) {
            trails[trailIdx].push({ x: trailX, y: trailY });
          }
          
          // Draw eigenvector trail (should be straight!)
          if (trails[trailIdx] && trails[trailIdx].length > 1) {
            ctx.strokeStyle = color;
            ctx.globalAlpha = 0.6;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(trails[trailIdx][0].x, trails[trailIdx][0].y);
            for (let i = 1; i < trails[trailIdx].length; i++) {
              ctx.lineTo(trails[trailIdx][i].x, trails[trailIdx][i].y);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
          }
          
          // Draw original eigenvector direction (dashed line through origin)
          ctx.strokeStyle = color;
          ctx.globalAlpha = 0.3;
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(centerX - ev[0] * vecLength * scale * 1.5, centerY + ev[1] * vecLength * scale * 1.5);
          ctx.lineTo(centerX + ev[0] * vecLength * scale * 1.5, centerY - ev[1] * vecLength * scale * 1.5);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.globalAlpha = 1;
          
          // Draw point on ORIGINAL circle at eigenvector direction
          ctx.fillStyle = color;
          ctx.globalAlpha = 0.5;
          ctx.beginPath();
          ctx.arc(
            centerX + ev[0] * vecLength * scale,
            centerY - ev[1] * vecLength * scale,
            8, 0, Math.PI * 2
          );
          ctx.fill();
          ctx.globalAlpha = 1;
          
          // Draw point on TRANSFORMED shape at eigenvector direction
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(
            centerX + transformedEv[0] * vecLength * scale,
            centerY - transformedEv[1] * vecLength * scale,
            10, 0, Math.PI * 2
          );
          ctx.fill();
          
          // Draw arrow from original to transformed position
          const arrowHeadLen = 10;
          const tipX = centerX + transformedEv[0] * vecLength * scale;
          const tipY = centerY - transformedEv[1] * vecLength * scale;
          const angle = Math.atan2(tipY - centerY, tipX - centerX);
          const arrowWidth = 6;
          
          ctx.beginPath();
          ctx.moveTo(tipX, tipY);
          ctx.lineTo(
            tipX - arrowHeadLen * Math.cos(angle) + arrowWidth * Math.cos(angle + Math.PI/2),
            tipY - arrowHeadLen * Math.sin(angle) + arrowWidth * Math.sin(angle + Math.PI/2)
          );
          ctx.lineTo(
            tipX - arrowHeadLen * Math.cos(angle) + arrowWidth * Math.cos(angle - Math.PI/2),
            tipY - arrowHeadLen * Math.sin(angle) + arrowWidth * Math.sin(angle - Math.PI/2)
          );
          ctx.closePath();
          ctx.fill();
          
          // Draw scale label
          ctx.fillStyle = color;
          ctx.font = 'bold 12px JetBrains Mono';
          const labelX = tipX + 18 * Math.cos(angle);
          const labelY = tipY + 18 * Math.sin(angle);
          ctx.fillText(`×${lambda.toFixed(1)}`, labelX - 12, labelY + 4);
        });
      }
      
      // For scalar matrix, show that ALL directions are eigenvectors
      if (isScalarMatrix && eigenData.l1) {
        ctx.fillStyle = '#00d4ff';
        ctx.font = 'bold 12px JetBrains Mono';
        ctx.fillText(`All directions scale by ×${eigenData.l1.toFixed(1)}`, 10, height - 10);
        
        // Draw a few sample points to show they all stay on radial lines
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2;
          const ev = [Math.cos(angle), Math.sin(angle)];
          const scaleFactor = 1 + currentT * (eigenData.l1 - 1);
          const transformedEv = [ev[0] * scaleFactor, ev[1] * scaleFactor];
          
          ctx.fillStyle = '#00d4ff';
          ctx.beginPath();
          ctx.arc(
            centerX + transformedEv[0] * vecLength * scale,
            centerY - transformedEv[1] * vecLength * scale,
            6, 0, Math.PI * 2
          );
          ctx.fill();
        }
      }

      // Draw origin
      ctx.fillStyle = '#ffd000';
      ctx.beginPath();
      ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
      ctx.fill();

      // Draw transformation label
      ctx.fillStyle = '#888';
      ctx.font = '11px JetBrains Mono';
      ctx.fillText(`Transform: ${(currentT * 100).toFixed(0)}%`, 10, 20);
      ctx.fillStyle = '#aaa';
      ctx.fillText(`Circle → Av (ellipse)`, 10, 35);
      
      // Special message for scalar matrix
      if (isScalarMatrix) {
        ctx.fillStyle = '#00d4ff';
        ctx.font = 'bold 14px JetBrains Mono';
        ctx.fillText(`ALL vectors are eigenvectors!`, 10, height - 20);
        ctx.fillStyle = '#888';
        ctx.font = '12px JetBrains Mono';
        ctx.fillText(`Every direction scales by λ = ${eigenData.l1.toFixed(1)}`, 10, height - 5);
      }
    }

    function compute() {
      const a = parseFloat(document.getElementById('a11').value);
      const b = parseFloat(document.getElementById('a12').value);
      const c = parseFloat(document.getElementById('a21').value);
      const d = parseFloat(document.getElementById('a22').value);

      matrixA = { a, b, c, d };
      initTrails(); // Reset trails when matrix changes
      eigenPauseFrames = 0;
      lastEigenHit = -1;

      // Helper to clean up floating point errors
      const cleanFloat = (x) => {
        // Round to various precision levels and check if close enough
        for (const precision of [1, 10, 100, 1000]) {
          const rounded = Math.round(x * precision) / precision;
          if (Math.abs(x - rounded) < 1e-6) return rounded;
        }
        return x;
      };

      const trace = cleanFloat(a + d);
      const det = cleanFloat(a * d - b * c);
      const discriminant = cleanFloat(trace * trace - 4 * det);

      const container = document.getElementById('steps-container');
      let html = '';

      html += `<div class="step">
        <span class="step-number">1</span>
        <span class="step-title">Characteristic equation 特征方程</span>
        <div class="step-content">
          <span class="math">det(A - λI) = 0</span>
          <div class="math-block">(${a.toFixed(2)}-λ)(${d.toFixed(2)}-λ) - (${b.toFixed(2)})(${c.toFixed(2)}) = 0
λ² - ${trace.toFixed(2)}λ + ${det.toFixed(2)} = 0</div>
        </div>
      </div>`;

      let lambda1, lambda2, eigenvector1, eigenvector2;
      
      if (discriminant < 0) {
        eigenData = { ev1: null, ev2: null, l1: null, l2: null };
        document.getElementById('lambda1').textContent = `${(trace/2).toFixed(2)}+${(Math.sqrt(-discriminant)/2).toFixed(2)}i`;
        document.getElementById('lambda2').textContent = `${(trace/2).toFixed(2)}-${(Math.sqrt(-discriminant)/2).toFixed(2)}i`;
        document.getElementById('ev1').textContent = 'complex';
        document.getElementById('ev2').textContent = 'complex';
        html += `<div class="step">
          <span class="step-number">2</span>
          <span class="step-title">Complex eigenvalues 复数特征值</span>
          <div class="step-content">Discriminant 判别式 = ${discriminant.toFixed(2)} < 0<br>No real eigenvectors exist. 无实数特征向量。</div>
        </div>`;
        container.innerHTML = html;
        drawRotateMode();
        return;
      }

      lambda1 = cleanFloat((trace + Math.sqrt(discriminant)) / 2);
      lambda2 = cleanFloat((trace - Math.sqrt(discriminant)) / 2);

      html += `<div class="step">
        <span class="step-number">2</span>
        <span class="step-title">Solve quadratic 求解二次方程</span>
        <div class="step-content">
          <div class="math-block">trace 迹 = ${trace.toFixed(2)}, det 行列式 = ${det.toFixed(2)}
discriminant 判别式 = ${discriminant.toFixed(2)}
λ = (${trace.toFixed(2)} ± √${discriminant.toFixed(2)}) / 2</div>
          <strong>λ₁ = ${lambda1.toFixed(2)}, λ₂ = ${lambda2.toFixed(2)}</strong>
        </div>
      </div>`;

      [lambda1, lambda2].forEach((lambda, idx) => {
        const m11 = a - lambda;
        const m12 = b;
        const m21 = c;
        const m22 = d - lambda;

        let vx, vy;
        
        // For repeated eigenvalues, use orthogonal vectors
        if (Math.abs(lambda1 - lambda2) < 0.0001) {
          if (idx === 0) {
            vx = 1; vy = 0;
          } else {
            vx = 0; vy = 1;
          }
        } else if (Math.abs(m12) > 0.0001) {
          vx = -m12; vy = m11;
        } else if (Math.abs(m21) > 0.0001) {
          vx = m22; vy = -m21;
        } else if (Math.abs(m11) > 0.0001) {
          vx = 0; vy = 1;
        } else if (Math.abs(m22) > 0.0001) {
          vx = 1; vy = 0;
        } else {
          // Fallback for identity-like matrices
          vx = idx === 0 ? 1 : 0; 
          vy = idx === 0 ? 0 : 1;
        }

        // Normalize
        const mag = Math.sqrt(vx*vx + vy*vy);
        if (mag > 0) { vx /= mag; vy /= mag; }
        
        // Prefer canonical direction: first significant component should be positive
        // This makes eigenvectors point in a consistent, intuitive direction
        const firstSignificant = Math.abs(vx) > 0.0001 ? vx : vy;
        if (firstSignificant < 0) {
          vx = -vx;
          vy = -vy;
        }

        if (idx === 0) eigenvector1 = [vx, vy];
        else eigenvector2 = [vx, vy];

        html += `<div class="step">
          <span class="step-number">${3+idx}</span>
          <span class="step-title">Eigenvector 特征向量 λ${idx+1}=${lambda.toFixed(2)}</span>
          <div class="step-content">
            <div class="math-block">(A - ${lambda.toFixed(2)}I)v = 0
[${(a-lambda).toFixed(2)}, ${b.toFixed(2)}][x]   [0]
[${c.toFixed(2)}, ${(d-lambda).toFixed(2)}][y] = [0]</div>
            <strong>v${idx+1} = [${vx.toFixed(2)}, ${vy.toFixed(2)}]</strong>
          </div>
        </div>`;
      });

      eigenData = { ev1: eigenvector1, ev2: eigenvector2, l1: lambda1, l2: lambda2 };

      // Check for scalar matrix (repeated eigenvalue, diagonal matrix)
      const isScalarMatrix = Math.abs(lambda1 - lambda2) < 0.0001 &&
        Math.abs(b) < 0.0001 && Math.abs(c) < 0.0001;

      // Update compact results
      document.getElementById('lambda1').textContent = lambda1.toFixed(2);
      document.getElementById('lambda2').textContent = lambda2.toFixed(2);
      
      if (isScalarMatrix) {
        document.getElementById('ev1').textContent = 'ALL vectors! 所有向量!';
        document.getElementById('ev2').textContent = 'ALL vectors! 所有向量!';
        html += `<div class="step">
          <span class="step-number">★</span>
          <span class="step-title">Special case 特殊情况: Scalar matrix 标量矩阵</span>
          <div class="step-content">
            <strong>Every vector is an eigenvector! 每个向量都是特征向量！</strong><br>
            This matrix scales all vectors by ${lambda1.toFixed(2)} without any rotation.<br>
            此矩阵将所有向量缩放 ${lambda1.toFixed(2)} 倍，无旋转。
          </div>
        </div>`;
      } else {
        document.getElementById('ev1').textContent = `[${eigenvector1[0].toFixed(2)}, ${eigenvector1[1].toFixed(2)}]`;
        document.getElementById('ev2').textContent = `[${eigenvector2[0].toFixed(2)}, ${eigenvector2[1].toFixed(2)}]`;
      }

      container.innerHTML = html;
      drawRotateMode();
    }

    // Initial computation and start animation
    setupCanvas();
    compute();
    animate();
    setupKeyboardNav();
    selectCell('a11'); // Select first cell by default
  </script>
</body>
</html>
