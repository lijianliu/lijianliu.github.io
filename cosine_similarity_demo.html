<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Similarity Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
            padding: 40px 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 8px;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .similarity-types {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .sim-type {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.8rem;
            background: rgba(255,255,255,0.05);
            color: #666;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .sim-type.active {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
            border-color: rgba(0, 212, 255, 0.4);
        }

        .formula {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 25px 20px;
            text-align: center;
            margin-bottom: 30px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .formula-text {
            font-size: 1.3rem;
            font-family: 'Times New Roman', Georgia, serif;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .fraction {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            vertical-align: middle;
            margin: 0 4px;
        }

        .fraction .numerator {
            border-bottom: 1.5px solid #e0e0e0;
            padding: 0 6px 4px 6px;
            font-size: 1rem;
        }

        .fraction .denominator {
            padding: 4px 6px 0 6px;
            font-size: 1rem;
        }

        .equals {
            margin: 0 2px;
            color: #888;
        }

        .result-value {
            color: #00d4ff;
            font-weight: bold;
            font-size: 1.4rem;
        }

        .vector-component {
            color: #00d4ff;
        }

        .vector-component-b {
            color: #ff6b6b;
        }

        .notation-guide {
            margin-top: 18px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            font-size: 0.85rem;
            color: #aaa;
        }

        .notation-item {
            display: inline;
        }

        .notation-item strong {
            color: #e0e0e0;
            font-family: 'Times New Roman', Georgia, serif;
        }

        .notation-divider {
            color: rgba(255,255,255,0.2);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 30px;
        }

        .canvas-container {
            background: rgba(0,0,0,0.3);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        canvas {
            display: block;
            margin: 0 auto;
            cursor: crosshair;
        }

        .instructions {
            text-align: center;
            font-size: 0.85rem;
            color: #888;
            margin-top: 15px;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            color: #aaa;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .result-card {
            background: rgba(255,255,255,0.05);
            border-radius: 16px;
            padding: 25px;
            border: 1px solid rgba(255,255,255,0.1);
            text-align: center;
        }

        .result-label {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #888;
            margin-bottom: 10px;
        }

        .similarity-value {
            font-size: 3.5rem;
            font-weight: 700;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .angle-value {
            font-size: 1.2rem;
            color: #aaa;
            margin-top: 5px;
        }

        .similarity-bar {
            margin-top: 20px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .similarity-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ffd93d, #6bcf63);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .interpretation {
            margin-top: 15px;
            padding: 12px;
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .interpretation.high {
            background: rgba(107, 207, 99, 0.2);
            color: #6bcf63;
        }

        .interpretation.medium {
            background: rgba(255, 217, 61, 0.2);
            color: #ffd93d;
        }

        .interpretation.low {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
        }

        .vector-info {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .vector-info h3 {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 15px;
        }

        .vector-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .vector-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .vector-a .vector-dot { background: #00d4ff; box-shadow: 0 0 10px #00d4ff; }
        .vector-b .vector-dot { background: #ff6b6b; box-shadow: 0 0 10px #ff6b6b; }

        .vector-coords {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .vector-length {
            margin-top: 8px;
        }

        .length-slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        .length-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
        }

        .vector-a .length-slider::-webkit-slider-thumb {
            background: #00d4ff;
            box-shadow: 0 0 8px #00d4ff;
        }

        .vector-b .length-slider::-webkit-slider-thumb {
            background: #ff6b6b;
            box-shadow: 0 0 8px #ff6b6b;
        }

        .length-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .vector-a .length-slider::-moz-range-thumb {
            background: #00d4ff;
            box-shadow: 0 0 8px #00d4ff;
        }

        .vector-b .length-slider::-moz-range-thumb {
            background: #ff6b6b;
            box-shadow: 0 0 8px #ff6b6b;
        }

        .length-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #666;
            margin-top: 4px;
        }

        .presets {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .presets h3 {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 15px;
        }

        .preset-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .preset-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            padding: 12px 15px;
            border-radius: 8px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            font-size: 0.85rem;
        }

        .preset-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: translateX(5px);
        }

        .preset-btn span {
            float: right;
            opacity: 0.6;
        }

        .nlp-example {
            background: rgba(123, 44, 191, 0.1);
            border: 1px solid rgba(123, 44, 191, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-top: 30px;
        }

        .nlp-example h3 {
            color: #b388ff;
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .word-pair {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .words {
            font-size: 1rem;
        }

        .word-similarity {
            font-weight: 600;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
        }

        .word-similarity.high { background: rgba(107, 207, 99, 0.3); color: #6bcf63; }
        .word-similarity.medium { background: rgba(255, 217, 61, 0.3); color: #ffd93d; }
        .word-similarity.low { background: rgba(255, 107, 107, 0.3); color: #ff6b6b; }

        @media (max-width: 800px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Vector Similarity Visualization</h1>
        <p class="subtitle">Exploring <strong>Cosine Similarity</strong> ‚Äî one of several ways to measure vector similarity</p>
        
        <div class="similarity-types">
            <span class="sim-type active">Cosine Similarity</span>
            <span class="sim-type">Euclidean Distance</span>
            <span class="sim-type">Dot Product</span>
            <span class="sim-type">Manhattan Distance</span>
        </div>

        <div class="formula">
            <div class="formula-text">
                <span>cos(Œ∏)</span>
                <span class="equals">=</span>
                <div class="fraction">
                    <span class="numerator">x ¬∑ y</span>
                    <span class="denominator">‚Äñx‚Äñ ‚Äñy‚Äñ</span>
                </div>
                <span class="equals">=</span>
                <div class="fraction">
                    <span class="numerator"><span class="vector-component">(<span id="xComp">0.87, 0.50</span>)</span> ¬∑ <span class="vector-component-b">(<span id="yComp">0.50, 0.87</span>)</span></span>
                    <span class="denominator"><span id="magA">1.00</span> √ó <span id="magB">1.00</span></span>
                </div>
                <span class="equals">=</span>
                <div class="fraction">
                    <span class="numerator" id="dotProduct">0.87</span>
                    <span class="denominator" id="magnitudeProduct">1.00</span>
                </div>
                <span class="equals">=</span>
                <span class="result-value" id="computedResult">0.87</span>
            </div>
            <div class="notation-guide">
                <span class="notation-item"><strong>x ¬∑ y</strong> = dot product = x‚ÇÅy‚ÇÅ + x‚ÇÇy‚ÇÇ</span>
                <span class="notation-divider">|</span>
                <span class="notation-item"><strong>‚Äñx‚Äñ</strong> = magnitude of x = ‚àö(x‚ÇÅ¬≤ + x‚ÇÇ¬≤)</span>
                <span class="notation-divider">|</span>
                <span class="notation-item"><strong>‚Äñx‚Äñ‚Äñy‚Äñ</strong> = product of magnitudes (normalizes the result)</span>
            </div>
        </div>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="vectorCanvas" width="500" height="500"></canvas>
                <p class="instructions">üñ±Ô∏è Drag the vector endpoints to change direction and length</p>
                <div class="legend">
                    <span class="legend-item"><span class="legend-color" style="background: #00d4ff;"></span> x vector</span>
                    <span class="legend-item"><span class="legend-color" style="background: #ff6b6b;"></span> y vector</span>
                    <span class="legend-item"><span class="legend-color" style="background: #ffd93d;"></span> projection of x onto y</span>
                </div>
            </div>

            <div class="sidebar">
                <div class="result-card">
                    <div class="result-label">Cosine Similarity</div>
                    <div class="similarity-value" id="similarityValue">1.00</div>
                    <div class="angle-value" id="angleValue">Œ∏ = 0¬∞</div>
                    <div class="similarity-bar">
                        <div class="similarity-fill" id="similarityBar" style="width: 100%"></div>
                    </div>
                    <div class="interpretation high" id="interpretation">
                        Identical direction ‚Äî Maximum similarity
                    </div>
                </div>

                <div class="vector-info">
                    <h3>Vector Components</h3>
                    <div class="vector-row vector-a">
                        <div class="vector-dot"></div>
                        <div style="flex: 1;">
                            <div class="vector-coords" id="vectorACoords">x = (1.00, 0.00)</div>
                            <div class="vector-length">
                                <input type="range" class="length-slider" id="lengthA" min="30" max="240" value="180">
                                <div class="length-label"><span>‚Äñx‚Äñ = <span id="lengthAValue">1.00</span></span></div>
                            </div>
                        </div>
                    </div>
                    <div class="vector-row vector-b">
                        <div class="vector-dot"></div>
                        <div style="flex: 1;">
                            <div class="vector-coords" id="vectorBCoords">y = (1.00, 0.00)</div>
                            <div class="vector-length">
                                <input type="range" class="length-slider" id="lengthB" min="30" max="240" value="180">
                                <div class="length-label"><span>‚Äñy‚Äñ = <span id="lengthBValue">1.00</span></span></div>
                            </div>
                        </div>
                    </div>
                    <div class="magnitude-note" style="margin-top: 12px; padding: 10px; background: rgba(123, 44, 191, 0.15); border-radius: 8px; font-size: 0.8rem; color: #b388ff;">
                        üí° Notice: Cosine similarity depends only on <em>direction</em>, not magnitude!
                    </div>
                </div>

                <div class="presets">
                    <h3>Try These Examples</h3>
                    <div class="preset-buttons">
                        <button class="preset-btn" onclick="setPreset(0, 0)">Same Direction <span>cos = 1</span></button>
                        <button class="preset-btn" onclick="setPreset(0, 90)">Perpendicular <span>cos = 0</span></button>
                        <button class="preset-btn" onclick="setPreset(0, 180)">Opposite <span>cos = -1</span></button>
                        <button class="preset-btn" onclick="setPreset(30, 60)">Similar <span>cos ‚âà 0.87</span></button>
                        <button class="preset-btn" onclick="setPreset(0, 120)">Dissimilar <span>cos = -0.5</span></button>
                        <button class="preset-btn" onclick="setPreset(45, 45, 80, 180)">Same dir, diff length <span>cos = 1</span></button>
                    </div>
                </div>
            </div>
        </div>

        <div class="nlp-example">
            <h3>üìö NLP Application: Word Embeddings</h3>
            <p style="margin-bottom: 15px; color: #aaa; font-size: 0.9rem;">
                In Natural Language Processing, words are converted to vectors. Words appearing in similar contexts have higher cosine similarity.
            </p>
            <div class="word-pair">
                <span class="words">"king" ‚Üî "prince"</span>
                <span class="word-similarity high">0.78</span>
            </div>
            <div class="word-pair">
                <span class="words">"king" ‚Üî "queen"</span>
                <span class="word-similarity high">0.68</span>
            </div>
            <div class="word-pair">
                <span class="words">"king" ‚Üî "man"</span>
                <span class="word-similarity medium">0.52</span>
            </div>
            <div class="word-pair">
                <span class="words">"cat" ‚Üî "dog"</span>
                <span class="word-similarity medium">0.59</span>
            </div>
            <div class="word-pair">
                <span class="words">"happy" ‚Üî "joyful"</span>
                <span class="word-similarity high">0.71</span>
            </div>
            <div class="word-pair">
                <span class="words">"computer" ‚Üî "banana"</span>
                <span class="word-similarity low">0.08</span>
            </div>
            <p style="margin-top: 15px; color: #888; font-size: 0.8rem; font-style: italic;">
                üí° Note: "king" and "queen" are similar because they share the "royalty" context, while "king" and "man" only share the "male" component. The famous analogy: king ‚àí man + woman ‚âà queen
            </p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('vectorCanvas');
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        let vectorA = { angle: 30, length: 180 };
        let vectorB = { angle: 60, length: 180 };
        let dragging = null;

        const lengthSliderA = document.getElementById('lengthA');
        const lengthSliderB = document.getElementById('lengthB');

        lengthSliderA.addEventListener('input', (e) => {
            vectorA.length = parseInt(e.target.value);
            draw();
        });

        lengthSliderB.addEventListener('input', (e) => {
            vectorB.length = parseInt(e.target.value);
            draw();
        });

        function degToRad(deg) {
            return deg * Math.PI / 180;
        }

        function radToDeg(rad) {
            return rad * 180 / Math.PI;
        }

        function getVectorEnd(angle, length) {
            const rad = degToRad(-angle);
            return {
                x: centerX + length * Math.cos(rad),
                y: centerY + length * Math.sin(rad)
            };
        }

        function getScaledVector(angle, length) {
            const rad = degToRad(-angle);
            const scale = length / 180;
            return {
                x: Math.cos(rad) * scale,
                y: -Math.sin(rad) * scale
            };
        }

        function getUnitVector(angle) {
            const rad = degToRad(-angle);
            return {
                x: Math.cos(rad),
                y: -Math.sin(rad)
            };
        }

        function calculateSimilarity() {
            const a = getUnitVector(vectorA.angle);
            const b = getUnitVector(vectorB.angle);
            return a.x * b.x + a.y * b.y;
        }

        function drawArrow(fromX, fromY, toX, toY, color, lineWidth = 3, label = '') {
            const headLength = 25;
            const headWidth = 12;
            const angle = Math.atan2(toY - fromY, toX - fromX);

            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';

            // Draw line (shortened to not overlap with arrowhead)
            const lineEndX = toX - headLength * Math.cos(angle);
            const lineEndY = toY - headLength * Math.sin(angle);
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(lineEndX, lineEndY);
            ctx.stroke();

            // Draw larger arrowhead
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 7), toY - headLength * Math.sin(angle - Math.PI / 7));
            ctx.lineTo(toX - headLength * 0.7 * Math.cos(angle), toY - headLength * 0.7 * Math.sin(angle));
            ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 7), toY - headLength * Math.sin(angle + Math.PI / 7));
            ctx.closePath();
            ctx.fill();
            
            // Draw label inside arrowhead
            if (label) {
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 12px sans-serif';
                const labelX = toX - headLength * 0.45 * Math.cos(angle);
                const labelY = toY - headLength * 0.45 * Math.sin(angle);
                ctx.fillText(label, labelX - 4, labelY + 4);
            }
        }

        function drawArc() {
            const startAngle = degToRad(-vectorA.angle);
            const endAngle = degToRad(-vectorB.angle);
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 50, Math.min(startAngle, endAngle), Math.max(startAngle, endAngle));
            ctx.stroke();

            const midAngle = (startAngle + endAngle) / 2;
            const labelX = centerX + 75 * Math.cos(midAngle);
            const labelY = centerY + 75 * Math.sin(midAngle);
            
            // Calculate the angle difference
            const angleDiff = Math.abs(vectorA.angle - vectorB.angle).toFixed(0);
            
            ctx.fillStyle = '#ffd93d';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(`Œ∏ = ${angleDiff}¬∞`, labelX - 20, labelY + 5);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid - 180px spacing = 1.0 units
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            const gridSpacing = 180; // 1.0 units
            for (let i = centerX % gridSpacing; i <= canvas.width; i += gridSpacing) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = centerY % gridSpacing; i <= canvas.height; i += gridSpacing) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();

            drawArc();

            const endA = getVectorEnd(vectorA.angle, vectorA.length);
            const endB = getVectorEnd(vectorB.angle, vectorB.length);

            // Calculate scaled vectors for dot product
            const scaledA = getScaledVector(vectorA.angle, vectorA.length);
            const scaledB = getScaledVector(vectorB.angle, vectorB.length);
            
            // Dot product = x‚ÇÅy‚ÇÅ + x‚ÇÇy‚ÇÇ
            const dotProduct = scaledA.x * scaledB.x + scaledA.y * scaledB.y;
            
            // Magnitude of B
            const magB = Math.sqrt(scaledB.x * scaledB.x + scaledB.y * scaledB.y);
            
            // Projection length of A onto B = (A ¬∑ B) / |B|
            const projectionScalar = magB > 0 ? dotProduct / magB : 0;
            
            // Unit vector in B's direction
            const unitBx = magB > 0 ? scaledB.x / magB : 0;
            const unitBy = magB > 0 ? scaledB.y / magB : 0;
            
            // Projection endpoint in canvas coordinates
            // Scale back to canvas size (180 is the base scale factor)
            const projEndX = centerX + projectionScalar * 180 * unitBx;
            const projEndY = centerY - projectionScalar * 180 * unitBy;
            
            // Draw dashed line from A endpoint to projection point (perpendicular drop)
            ctx.strokeStyle = 'rgba(255, 217, 61, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(endA.x, endA.y);
            ctx.lineTo(projEndX, projEndY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw projection vector (from origin to projection point)
            ctx.strokeStyle = '#ffd93d';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(projEndX, projEndY);
            ctx.stroke();
            
            // Draw projection endpoint dot
            ctx.fillStyle = '#ffd93d';
            ctx.beginPath();
            ctx.arc(projEndX, projEndY, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Label for projection - show dot product value
            const projLabelOffsetX = projEndX > centerX ? 10 : -100;
            const projLabelOffsetY = projEndY > centerY ? 20 : -10;
            ctx.fillStyle = '#ffd93d';
            ctx.font = '11px sans-serif';
            ctx.fillText(`x¬∑y = ${dotProduct.toFixed(2)}`, projEndX + projLabelOffsetX, projEndY + projLabelOffsetY);
            
            // Calculate magnitudes
            const magA = Math.sqrt(scaledA.x * scaledA.x + scaledA.y * scaledA.y);
            
            // ========== AREA VISUALIZATION ==========
            // Show ‚Äñx‚Äñ√ó‚Äñy‚Äñ as rectangle area, with x¬∑y as a portion
            const areaBoxX = 20;
            const areaBoxY = 25; // moved down to prevent ‚Äñy‚Äñ label from being cut off
            const areaScale = 80; // scale for visualization
            const rectW = magA * areaScale;
            const rectH = magB * areaScale;
            
            // Total area rectangle ‚Äñx‚Äñ√ó‚Äñy‚Äñ
            ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.fillRect(areaBoxX, areaBoxY, rectW, rectH);
            ctx.strokeRect(areaBoxX, areaBoxY, rectW, rectH);
            
            // Filled portion representing x¬∑y (dot product)
            // x¬∑y can be negative, so handle that visually
            const similarity = dotProduct / (magA * magB);
            const filledH = rectH * Math.abs(similarity);
            
            if (dotProduct >= 0) {
                // Positive: fill from bottom with yellow
                ctx.fillStyle = 'rgba(255, 217, 61, 0.4)';
                ctx.fillRect(areaBoxX, areaBoxY + rectH - filledH, rectW, filledH);
            } else {
                // Negative: fill from top with red to show "opposite"
                ctx.fillStyle = 'rgba(255, 107, 107, 0.4)';
                ctx.fillRect(areaBoxX, areaBoxY, rectW, filledH);
            }
            
            // Labels
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 12.5px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`‚Äñx‚Äñ=${magA.toFixed(2)}`, areaBoxX + rectW/2, areaBoxY + rectH + 16);
            
            ctx.fillStyle = '#ff6b6b';
            ctx.save();
            ctx.translate(areaBoxX - 10, areaBoxY + rectH/2);
            ctx.rotate(-Math.PI/2);
            ctx.textAlign = 'center';
            ctx.fillText(`‚Äñy‚Äñ=${magB.toFixed(2)}`, 0, 0);
            ctx.restore();
            
            // Draw bracket for x¬∑y (filled portion) - INNER bracket (closer to rectangle)
            let xyBracketEnd = areaBoxX + rectW + 17; // where the yellow bracket ends
            if (dotProduct >= 0) {
                ctx.strokeStyle = 'rgba(255, 217, 61, 0.6)';
                const bracketTop = areaBoxY + rectH - filledH;
                const bracketBottom = areaBoxY + rectH;
                const bracketMid = bracketTop + filledH/2;
                
                ctx.beginPath();
                ctx.moveTo(areaBoxX + rectW + 5, bracketTop);
                ctx.quadraticCurveTo(areaBoxX + rectW + 12, bracketTop, areaBoxX + rectW + 12, bracketTop + 5);
                ctx.lineTo(areaBoxX + rectW + 12, bracketMid - 3);
                ctx.lineTo(areaBoxX + rectW + 17, bracketMid);
                ctx.lineTo(areaBoxX + rectW + 12, bracketMid + 3);
                ctx.lineTo(areaBoxX + rectW + 12, bracketBottom - 5);
                ctx.quadraticCurveTo(areaBoxX + rectW + 12, bracketBottom, areaBoxX + rectW + 5, bracketBottom);
                ctx.stroke();
                
                // x¬∑y label - right after the bracket point with proper spacing
                ctx.fillStyle = '#ffd93d';
                ctx.fillText(`x¬∑y=${dotProduct.toFixed(2)}`, areaBoxX + rectW + 45, bracketMid + 4);
            } else {
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.6)';
                const bracketTop = areaBoxY;
                const bracketBottom = areaBoxY + filledH;
                const bracketMid = bracketTop + filledH/2;
                
                ctx.beginPath();
                ctx.moveTo(areaBoxX + rectW + 5, bracketTop);
                ctx.quadraticCurveTo(areaBoxX + rectW + 12, bracketTop, areaBoxX + rectW + 12, bracketTop + 5);
                ctx.lineTo(areaBoxX + rectW + 12, bracketMid - 3);
                ctx.lineTo(areaBoxX + rectW + 17, bracketMid);
                ctx.lineTo(areaBoxX + rectW + 12, bracketMid + 3);
                ctx.lineTo(areaBoxX + rectW + 12, bracketBottom - 5);
                ctx.quadraticCurveTo(areaBoxX + rectW + 12, bracketBottom, areaBoxX + rectW + 5, bracketBottom);
                ctx.stroke();
                
                // x¬∑y label - right after the bracket point with proper spacing
                ctx.fillStyle = '#ff6b6b';
                ctx.fillText(`x¬∑y=${dotProduct.toFixed(2)}`, areaBoxX + rectW + 45, bracketMid + 4);
            }
            
            // Draw bracket on right side for full rectangle ‚Äñx‚Äñ¬∑‚Äñy‚Äñ - OUTER bracket (small gap after x¬∑y label)
            const outerBracketStart = areaBoxX + rectW + 70; // moved closer to x¬∑y label
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(outerBracketStart, areaBoxY);
            ctx.quadraticCurveTo(outerBracketStart + 10, areaBoxY, outerBracketStart + 10, areaBoxY + 10);
            ctx.lineTo(outerBracketStart + 10, areaBoxY + rectH/2 - 5);
            ctx.lineTo(outerBracketStart + 15, areaBoxY + rectH/2);
            ctx.lineTo(outerBracketStart + 10, areaBoxY + rectH/2 + 5);
            ctx.lineTo(outerBracketStart + 10, areaBoxY + rectH - 10);
            ctx.quadraticCurveTo(outerBracketStart + 10, areaBoxY + rectH, outerBracketStart, areaBoxY + rectH);
            ctx.stroke();
            
            // ‚Äñx‚Äñ¬∑‚Äñy‚Äñ label on right side of outer bracket
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`‚Äñx‚Äñ¬∑‚Äñy‚Äñ=${(magA * magB).toFixed(2)}`, outerBracketStart + 18, areaBoxY + rectH/2 + 4);
            
            // Percentage inside the filled area
            const percentage = Math.round(Math.abs(similarity) * 100);
            ctx.textAlign = 'center';
            if (dotProduct >= 0) {
                ctx.fillStyle = '#ffd93d';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText(`${percentage}%`, areaBoxX + rectW/2, areaBoxY + rectH - filledH/2 + 5);
            } else {
                ctx.fillStyle = '#ff6b6b';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText(`${percentage}%`, areaBoxX + rectW/2, areaBoxY + filledH/2 + 5);
            }
            
            ctx.textAlign = 'left'; // reset

            drawArrow(centerX, centerY, endA.x, endA.y, '#00d4ff', 4, 'x');
            drawArrow(centerX, centerY, endB.x, endB.y, '#ff6b6b', 4, 'y');

            // Draw x vector values next to endpoint (use scaledA from projection calculation)
            ctx.fillStyle = '#00d4ff';
            ctx.font = '12px monospace';
            const labelOffsetAx = endA.x > centerX ? 15 : -115;
            const labelOffsetAy = endA.y > centerY ? 25 : -15;
            ctx.fillText(`x‚ÇÅ=${scaledA.x.toFixed(2)}, x‚ÇÇ=${scaledA.y.toFixed(2)}`, endA.x + labelOffsetAx, endA.y + labelOffsetAy);

            // Draw y vector values next to endpoint (use scaledB from projection calculation)
            ctx.fillStyle = '#ff6b6b';
            ctx.font = '12px monospace';
            const labelOffsetBx = endB.x > centerX ? 15 : -115;
            const labelOffsetBy = endB.y > centerY ? 25 : -15;
            ctx.fillText(`y‚ÇÅ=${scaledB.x.toFixed(2)}, y‚ÇÇ=${scaledB.y.toFixed(2)}`, endB.x + labelOffsetBx, endB.y + labelOffsetBy);

            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            ctx.fill();

            updateDisplay();
        }

        function updateDisplay() {
            const similarity = calculateSimilarity();
            const angleDiff = Math.abs(vectorA.angle - vectorB.angle);
            
            document.getElementById('similarityValue').textContent = similarity.toFixed(2);
            document.getElementById('angleValue').textContent = `Œ∏ = ${angleDiff.toFixed(0)}¬∞`;
            
            const barWidth = ((similarity + 1) / 2) * 100;
            document.getElementById('similarityBar').style.width = barWidth + '%';

            const scaledA = getScaledVector(vectorA.angle, vectorA.length);
            const scaledB = getScaledVector(vectorB.angle, vectorB.length);
            const magA = vectorA.length / 180;
            const magB = vectorB.length / 180;
            
            // Calculate dot product and magnitudes for formula display
            const dotProduct = scaledA.x * scaledB.x + scaledA.y * scaledB.y;
            const magnitudeA = Math.sqrt(scaledA.x * scaledA.x + scaledA.y * scaledA.y);
            const magnitudeB = Math.sqrt(scaledB.x * scaledB.x + scaledB.y * scaledB.y);
            const magnitudeProduct = magnitudeA * magnitudeB;
            
            // Update intermediate expression with vector components
            document.getElementById('xComp').textContent = `${scaledA.x.toFixed(2)}, ${scaledA.y.toFixed(2)}`;
            document.getElementById('yComp').textContent = `${scaledB.x.toFixed(2)}, ${scaledB.y.toFixed(2)}`;
            document.getElementById('magA').textContent = magnitudeA.toFixed(2);
            document.getElementById('magB').textContent = magnitudeB.toFixed(2);
            
            document.getElementById('dotProduct').textContent = dotProduct.toFixed(2);
            document.getElementById('magnitudeProduct').textContent = magnitudeProduct.toFixed(2);
            document.getElementById('computedResult').textContent = similarity.toFixed(2);
            
            document.getElementById('vectorACoords').textContent = `x = (${scaledA.x.toFixed(2)}, ${scaledA.y.toFixed(2)})`;
            document.getElementById('vectorBCoords').textContent = `y = (${scaledB.x.toFixed(2)}, ${scaledB.y.toFixed(2)})`;
            document.getElementById('lengthAValue').textContent = magA.toFixed(2);
            document.getElementById('lengthBValue').textContent = magB.toFixed(2);

            const interp = document.getElementById('interpretation');
            if (similarity > 0.7) {
                interp.className = 'interpretation high';
                interp.textContent = 'High similarity ‚Äî Vectors point in similar directions';
            } else if (similarity > 0.3) {
                interp.className = 'interpretation medium';
                interp.textContent = 'Moderate similarity ‚Äî Some directional alignment';
            } else if (similarity > -0.3) {
                interp.className = 'interpretation medium';
                interp.textContent = 'Low similarity ‚Äî Vectors are nearly perpendicular';
            } else if (similarity > -0.7) {
                interp.className = 'interpretation low';
                interp.textContent = 'Negative similarity ‚Äî Vectors point apart';
            } else {
                interp.className = 'interpretation low';
                interp.textContent = 'Opposite directions ‚Äî Maximum dissimilarity';
            }
        }

        function setPreset(angleA, angleB, lengthA = 180, lengthB = 180) {
            vectorA.angle = angleA;
            vectorB.angle = angleB;
            vectorA.length = lengthA;
            vectorB.length = lengthB;
            lengthSliderA.value = lengthA;
            lengthSliderB.value = lengthB;
            draw();
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function distanceToPoint(pos, point) {
            return Math.sqrt((pos.x - point.x) ** 2 + (pos.y - point.y) ** 2);
        }

        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);
            const endA = getVectorEnd(vectorA.angle, vectorA.length);
            const endB = getVectorEnd(vectorB.angle, vectorB.length);

            if (distanceToPoint(pos, endA) < 30) {
                dragging = 'A';
            } else if (distanceToPoint(pos, endB) < 30) {
                dragging = 'B';
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            
            const pos = getMousePos(e);
            const dx = pos.x - centerX;
            const dy = pos.y - centerY;
            const angle = -radToDeg(Math.atan2(dy, dx));
            const length = Math.min(240, Math.max(30, Math.sqrt(dx * dx + dy * dy)));

            if (dragging === 'A') {
                vectorA.angle = angle;
                vectorA.length = length;
                lengthSliderA.value = length;
            } else {
                vectorB.angle = angle;
                vectorB.length = length;
                lengthSliderB.value = length;
            }
            
            draw();
        });

        canvas.addEventListener('mouseup', () => {
            dragging = null;
        });

        // Listen for mouseup on document so drag continues even when cursor leaves canvas
        document.addEventListener('mouseup', () => {
            dragging = null;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const pos = getMousePos(touch);
            const endA = getVectorEnd(vectorA.angle, vectorA.length);
            const endB = getVectorEnd(vectorB.angle, vectorB.length);

            if (distanceToPoint(pos, endA) < 40) {
                dragging = 'A';
            } else if (distanceToPoint(pos, endB) < 40) {
                dragging = 'B';
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            if (!dragging) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const pos = getMousePos(touch);
            const dx = pos.x - centerX;
            const dy = pos.y - centerY;
            const angle = -radToDeg(Math.atan2(dy, dx));
            const length = Math.min(240, Math.max(30, Math.sqrt(dx * dx + dy * dy)));

            if (dragging === 'A') {
                vectorA.angle = angle;
                vectorA.length = length;
                lengthSliderA.value = length;
            } else {
                vectorB.angle = angle;
                vectorB.length = length;
                lengthSliderB.value = length;
            }
            
            draw();
        });

        canvas.addEventListener('touchend', () => {
            dragging = null;
        });

        draw();
    </script>
</body>
</html>
